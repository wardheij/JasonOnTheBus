; table extension required for messaging
extensions [table]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  pass
  pass_list
  
  ; Local variables for determining the target and a path
  target
  path
  
  ; Where was this bus spawned
  original
  
  ; How many buses are spawned
  number_of_buses
  
  ; What is the bus size
  bus_size
  
  ; Messaging variables for week 3
  master_id
  passenger_count
  received_message
  message_sender
  message_contents
  message_count
  
  ; Used to find the amount of stops
  network_size
  
  ; Path cache
  cache_path
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  
  ; General variables
  set path []
  set target current_stop
  set original current_stop
  
  ; Determine bus_size
  if bus_type = 1
  [
    set bus_size 12
  ]
  if bus_type = 2
  [
    set bus_size 60
  ]
  if bus_size = 3
  [
    set bus_size 150
  ]
  
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ; Variables required for counting passengers and such
  set network_size length graph
  set master_id network_size
  
  set number_of_buses number_of_buses + 1
  
  init-buses-strat-2
  
  set cache_path table:make
  
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  let total_passengers total-passengers
  
  if total_passengers > 0 or length bus_passengers > 0
  [
    do-strat-2
    
    ; sends a message to master if this agent votes for a new bus
    request-add-bus
    
    move
  ]
      
  ; MASTER AGENT
  if bus_id = master_id 
  [

    ; retrieve messages from inbox
    get-messages
    
    ; if master is the only bus, the master is a dictator and determines whether a bus is added
    ; for #buses > 1, we take a plurality vote on whether to add buses
    ifelse number_of_buses = 1
    [dictator-vote]
    [plurality-vote]
    
    ; clear inbox to correctly count votes
    set inbox []
  ]
end

to message-to [to_bus_id]
  
  ; obtain passenger count
  set passenger_count length bus_passengers
  
  ; create message dictionary containing update on the current status of the bus.
  ; status updates like these are useful for messages sent by slaves to the master.
  let dict table:make 

  ; vote for an additional bus
  table:put dict "request bus" 1
  
  ; This is simply an example of a message containing simple bus information. If desired, this message 
  ; structure may be expanded indefinitely by adding fields. 
  ; for instance, if we desire that the master should be able to send commands to slave buses, we might 
  ;     1. add a field containing a target destination for the recipient of the message;
  ;     2. create a new messaging function specifically for sending target commands, where the only fields are 
  ;        the commands from the master to the slave bus
  ;
  ; this process may be repeated with any number of fields for any purpose. Hence, this communication 
  ; infrastructure may be used for any purpose by retrieving the desired field from the dict.
  
  ; send message to required bus
  send-message to_bus_id dict
  
end

to-report occupancy
  let total 0
  let amount 0
  ask buses 
  [
    set amount amount + 1
    set total total + (length bus_passengers / bus_size)
  ]
  ifelse amount = 0
  [
    report 0
  ]
  [
    report total / amount
  ]
end

to-report bus-volume
  let total 0
  ask buses 
  [
    set total total + bus_size
  ]
  report total
end

to-report total-passengers
  let total 0
  
  if ticks != 0 
  [
    let i 0
    while [i < 24]
    [
      set total total + length get-passengers-at-stop i
      set i i + 1
    ]
  ]
  report total
end

to get-messages
  
  ; only process messages if any exist
  if length inbox > 0 
  [ 
    ; calculate number of messages received    
    set message_count length inbox
    
    ; select last message from inbox
    set received_message item (message_count - 1) inbox
    
    ; select the sender ID and message contents from the message
    set message_sender first received_message
    set message_contents item 2 received_message 
    
  ]
  
end

to plurality-vote
  ; Decide whether or not to add a new bus, based on the number of votes recieved by the master agent.
  ; When more than 25% of the buses vote 'pro' at the same time, a bus is added. 
  ; Note: not voting counts as a vote against, in order to send a minimum number of messages.
  if message_count > (0.25 * number_of_buses)
  [
    do-add-buses
  ] 
end

to dictator-vote
  ; Master agent decides to add a bus when the number of waiting passengers at Amsterdam CS exceeds the bus size. 
  if length get-passengers-at-stop original > (bus_size)
  [
    do-add-buses
  ]
end

to request-add-bus
  ; Vote for the addition of a bus if a bus observes more than 8 waiting passengers at its current stop.
  if not (current_stop = -1)
  [
    if length get-passengers-at-stop current_stop > 8 [message-to master_id]
  ]

end

to do-add-buses 
  let total_passengers total-passengers
  
  let bus_ratio int ((total_passengers - (number_of_buses * 60)) / 60)
  
  if bus_ratio > 1
  [
    repeat bus_ratio [add-bus 2]
    
    set number_of_buses number_of_buses + bus_ratio
  ]
end
    
to-report sort-destinations [destinations]
  ; destinations is a list of lists
  ; sorts the route lists based on their first item
  report sort-by [first ?1 < first ?2] destinations 
end

to-report get-path
  ; Find the destination based on a priority queue;
  ; - Add neighbours to queue [distance [list_of_path]]
  ; - Sort queue
  ; - If target is found, stop
  
  let index (target * 24) + current_stop
  
  if table:has-key? cache_path index
  [
    report table:get cache_path index
  ]
  
  let destinations []
  
  foreach item current_stop graph
  [
    ; If target is among neighbours, path to target is target
    if ? = target
    [
      let return lput target path
      table:put cache_path index return
      report return
    ]
    
    ; If not, start A*
    let dist get-distance current_stop ?
    set destinations lput (list dist (list ?)) destinations    
  ]
  

  loop
  [
    set destinations sort-destinations destinations
    
    let this_path (last (first destinations))
    let this_place last this_path
    let this_dist (first (first destinations))
    
    ; Pop from queue
    set destinations but-first destinations
    
    ; Check neighbours
    foreach item this_place graph
    [
      ; Stop when the target is found
      if ? = target
      [
        let return lput target this_path
        table:put cache_path index return
        report return
      ]
    
      ; Update queue
      let dist get-distance this_place ? + this_dist
      set destinations lput (list dist (lput ? this_path)) destinations
    ]
  ]
  
end

to init-busses-strat-1
  if previous_stop = -1 
  [
    if bus_id < 47
    [
      add-bus 1
    ]
    set target bus_id - network_size 
  ]
end

to get-passenger-target-strat-1
  if current_stop = bus_id - network_size 
  [
    set pass_list get-passengers-at-stop current_stop
    if length pass_list > 0
    [
      set pass item 0 get-passengers-at-stop current_stop
      
      pick-up-passenger item 0 pass
      
      set target item 1 pass
    ]
  ]
end

to passenger-actions-strat-1
  if length bus_passengers > 0
  [
    if current_stop = item 1 item 0 bus_passengers
    [
      drop-off-passenger item 0 item 0 bus_passengers
      set target bus_id - network_size
    ]
  ]
end

to do-strat-1
  init-busses-strat-1
  
  get-passenger-target-strat-1
  
  passenger-actions-strat-1
end

to init-buses-strat-2
  set target bus_id mod network_size
end

to do-strat-2
  
  check-for-drop
  
  ; If we are at the transfer-hub
  if current_stop = original
  [
    ; Drop all passengers
    foreach bus_passengers 
    [
      drop-off-passenger first ?
    ]
    
    
    ; TODO: Determine biggest group
    ; TODO: Set (correct) target (currently just goes to the first target, or any stop with passengers...) 
    ifelse length get-passengers-at-stop original > 0
    [
      ; First gets us the best results, "oldest passenger first".
      set target item 1 first get-passengers-at-stop original
      
      ; Pretty good.
      ;set target item 1 one-of get-passengers-at-stop original
     
      ; Pretty good, but not enough visits to buikslotermeer
      ;set target get-best-destination-at-stop original
      
      ; Worst results
      ;set target item 1 last get-passengers-at-stop original
      
      ; Doesn't work since all buses will go to this stop now..
      ;set target stop-with-most-waiting
    ]
    [
      ; If there are no passengers to transfer, go to a stop with passengers TODO COORD
      let i 0
      
      let tmp_list []
      
      while [i < network_size] 
      [
        if length get-passengers-at-stop i > 0
        [
          set tmp_list lput i tmp_list
        ]
        set i i + 1
      ]
      
      if length tmp_list > 0 
      [
      set target one-of tmp_list
      ]
    ]
    
    ; Get the new path
    if current_stop != target
    [
      set path get-path
    ]
  ]
  
  if target = current_stop
  [
    set target original
  ]
  
  ; Always check for pickup first, then fill the bus with transfers.
  check-for-pickup

  
  if current_stop != -1 and target = original
  [
    let i 0
    let limit min list (bus_size - length bus_passengers) (length get-passengers-at-stop current_stop)
    
    while [i < limit]
    [
      pick-up-passenger first first get-passengers-at-stop current_stop
      set i i + 1
    ]
  ]
  

  
end

to move
  ; Update path if nessesary
  if not empty? path and first path = current_stop 
  [
    set path but-first path
  ]
  
  ; If there is no updated target
  if not (current_stop = target)
  [
    ; Get the path to target if there is no path
    if empty? path
    [
      set path get-path  
    ]
    
    ; Move along the path
    travel-to first path
  ]
end

to-report get-best-destination-at-stop [x]
  let destinations_at_stop []
  let most_occurring_destination 0
  
  ; obtain a list of destinations at each stop
  foreach get-passengers-at-stop x
  [
    set destinations_at_stop lput item 1 ? destinations_at_stop    
  ]
  
  ; extract the most occurring destinations from the destination list, find how often the most frequent one occurs
  if length destinations_at_stop > 0 
  [
    set most_occurring_destination first modes destinations_at_stop 
  ]
  
  report most_occurring_destination
end

to-report stop-with-most-waiting
  let best 0
  let best_amount 0
  
  let i 0
  while [i < 24]
  [
    let current_amount length get-passengers-at-stop i
    if current_amount > best_amount and i != original
    [
      set best i
      set best_amount current_amount
    ]
    set i i + 1
  ]
  
  report best
end

; Check if a passenger currently in the bus can be dropped off at the current stop.
to check-for-drop

  foreach bus_passengers
  [
    if current_stop = item 1 ?
    [
      drop-off-passenger first ?
    ]
    
  ]
  
end

; Check if there are any passengers at the current stop with a destination on the bus' path list and if so, pick 'em up. 
to check-for-pickup

  ifelse current_stop = -1
  [
    stop
  ]
  [
    foreach get-passengers-at-stop current_stop
    [
      if length bus_passengers = bus_size
      [
        stop
      ]
      if (member? item 1 ? path)
      [
        pick-up-passenger first ?
      ]
      
    ]
  ]
  
end


