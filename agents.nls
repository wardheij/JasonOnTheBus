; table extension required for messaging
extensions [table]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  pass
  pass_list
  
  ; Local variables for determining the target and a path
  target
  path
  
  ; Where was this bus spawned
  original
  
  ; Temporary variables for finding the shortest route
  destinations
  dist
  this_path
  this_place
  this_dist
  
  ; Messaging variables for week 3
  master_id
  passenger_count
  received_message
  message_sender
  message_contents
  message_count
  
  ; Passenger counting
  total_passengers
  stops_list
  destinations_at_stop
  most_occurring_destination
  occurrences
  max_occurrences
  destination_list
  
  ; Used to find the amount of stops
  network_size
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  
  ; General variables
  set path []
  set destinations []
  set target current_stop
  set original current_stop
  
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ; Variables required for counting passengers and such
  set stops_list n-values (length graph - 1) [? + 1]
  set network_size length graph
  set master_id network_size
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.

  ask buses 
  [
    do-strat-1
     
    move
    
    get-total-passengers
    check-for-pickup
        
;    ; MASTER AGENT
;    if bus_id = master_id 
;    [
;      get-message
;    ]
;    
;    ; send a message to the master if a bus carries passengers reporting passenger count
;    if length bus_passengers > 0 
;    [
;      message-to master_id
;    ]
  ]
end

to message-to [to_bus_id]
  
  ; obtain passenger count
  set passenger_count length bus_passengers
  
  ; create message dictionary containing update on the current status of the bus.
  ; status updates like these are useful for messages sent by slaves to the master.
  let dict table:make 
  table:put dict "passenger count" passenger_count
  table:put dict "target" target
  table:put dict "passengers" bus_passengers
  table:put dict "current stop" current_stop
  table:put dict "previous stop" previous_stop
  
  ; This is simply an example of a message containing simple bus information. If desired, this message 
  ; structure may be expanded indefinitely by adding fields. 
  ; for instance, if we desire that the master should be able to send commands to slave buses, we might 
  ;     1. add a field containing a target destination for the recipient of the message;
  ;     2. create a new messaging function specifically for sending target commands, where the only fields are 
  ;        the commands from the master to the slave bus
  ;
  ; this process may be repeated with any number of fields for any purpose. Hence, this communication 
  ; infrastructure may be used for any purpose by retrieving the desired field from the dict.
  
  ; send message to required bus
  send-message to_bus_id dict
  
end


to get-message
  
  ; only process messages if any exist
  if length inbox > 0 
  [ 
    
    ; calculate number of messages received    
    set message_count length inbox
    
    ; select last message from inbox
    set received_message item (message_count - 1) inbox
    
    ; select the sender ID and message contents from the message
    set message_sender first received_message
    set message_contents item 2 received_message 
    
;    print table:get message_contents "target"
    
  ]
  
end
    
to sort-destinations
  ; destinations is a list of lists
  ; sorts the route lists based on their first item
  set destinations sort-by [first ?1 < first ?2] destinations 
end

to get-path
  ; Find the destination based on a priority queue;
  ; - Add neighbours to queue [distance [list_of_path]]
  ; - Sort queue
  ; - If target is found, stop
  
  set destinations []
  
  foreach item current_stop graph
  [
    ; If target is among neighbours, path to target is target
    if ? = target
    [
      set path lput target path
      stop
    ]
    
    ; If not, start A*
    set dist get-distance current_stop ?
    set destinations lput (list dist (list ?)) destinations    
  ]
  

  loop
  [
    sort-destinations
    
    set this_path (last (first destinations))
    set this_place last this_path
    set this_dist (first (first destinations))
    
    ; Pop from queue
    set destinations but-first destinations
    
    ; Check neighbours
    foreach item this_place graph
    [
      ; Stop when the target is found
      if ? = target
      [
        set path lput target this_path
        stop
      ]
    
      ; Update queue
      set dist get-distance this_place ? + this_dist
      set destinations lput (list dist (lput ? this_path)) destinations
    ]
  ]
  
end

to init-busses-strat-1
  if previous_stop = -1 
  [
    if bus_id < 47
    [
      add-bus 1
    ]
    set target bus_id - network_size 
  ]
end

to get-passenger-target-strat-1
  if current_stop = bus_id - network_size 
  [
    set pass_list get-passengers-at-stop current_stop
    if length pass_list > 0
    [
      set pass item 0 get-passengers-at-stop current_stop
      
      pick-up-passenger item 0 pass
      
      set target item 1 pass
    ]
  ]
end

to passenger-actions-strat-1
  if length bus_passengers > 0
  [
    if current_stop = item 1 item 0 bus_passengers
    [
      drop-off-passenger item 0 item 0 bus_passengers
      set target bus_id - network_size
    ]
  ]
end

to do-strat-1
  init-busses-strat-1
  
  get-passenger-target-strat-1
  
  passenger-actions-strat-1
end

to do-strat-2
  init-busses-strat-1
  
end

to move
  ; Update path if nessesary
  if not empty? path and first path = current_stop 
  [
    set path but-first path
  ]
  
  ; If there is no updated target
  if not (current_stop = target)
  [
    ; Get the path to target if there is no path
    if empty? path
    [
      get-path  
    ]
    
    ; Move along the path
    travel-to first path
  ]
end

to get-total-passengers
  ; get total number of passengers currently waiting at stops AND a list of stops having the largest number of passengers with common destination

  set total_passengers 0
  set destination_list []
  set max_occurrences 0
  
  foreach stops_list
  [
    ; update total number of passengers
    set total_passengers total_passengers + length get-passengers-at-stop ?
    
    ; obtain a list of destinations at each stop
    set destinations_at_stop []
    foreach get-passengers-at-stop ?
    [
      set destinations_at_stop lput item 1 ? destinations_at_stop    
    ]
    
    ; extract the most occurring destinations from the destination list, find how often the most frequent one occurs
    if length destinations_at_stop > 0 [
      set most_occurring_destination first modes destinations_at_stop 
      
      ; count how often the most frequent destination occurs at each stop
      set occurrences 0
      foreach destinations_at_stop
      [
        if most_occurring_destination = ? [set occurrences occurrences + 1]
      ]
      
      ; now build a sorted list of stops, based on how many passengers with the same destination are at that stop
      ; we count whether the number of occurences of a destination at that stop exceeds the global maximum.
      ; if so, we place that stop to the front of the list (meaning it has the highest priority) and set this destination count as the new global maximum
      ; if not, we place it at the back of the list
      ; returns destination_list, of which the first item is the stop with the most passengers having a common destination
      ifelse occurrences > max_occurrences
      [
        set destination_list fput ? destination_list
        set max_occurrences occurrences
      ]
      [
        set destination_list lput ? destination_list
      ]
    ]
    
  ]
  
  
end

to check-for-drop

  foreach bus_passengers
  [
    if current_stop = item 1 ?
    [
      drop-off-passenger first ?
    ]
    
  ]
  
end

to check-for-pickup

  ifelse current_stop = -1
  [
    stop
  ]
  [
    foreach get-passengers-at-stop current_stop
    [
      if (member? item 1 ? path)
      [
        pick-up-passenger first ?
      ]
      
    ]
  ]
  
end
